import{_ as a,c as n,o as e,a4 as s,m as l,a as i}from"./chunks/framework.Xe-pYyW9.js";const b=JSON.parse('{"title":"浏览器","description":"","frontmatter":{},"headers":[],"relativePath":"question/index.md","filePath":"question/index.md","lastUpdated":null}'),t={name:"question/index.md"},h=s('<h1 id="浏览器" tabindex="-1">浏览器 <a class="header-anchor" href="#浏览器" aria-label="Permalink to &quot;浏览器&quot;">​</a></h1><h1 id="webpack" tabindex="-1">webpack <a class="header-anchor" href="#webpack" aria-label="Permalink to &quot;webpack&quot;">​</a></h1><h2 id="webpack-基本概念" tabindex="-1">webpack 基本概念 <a class="header-anchor" href="#webpack-基本概念" aria-label="Permalink to &quot;webpack 基本概念&quot;">​</a></h2><ol><li>entry 入口 <ul><li>以某个文件为入口开始打包</li><li>分类 <ul><li><p>单入口 String</p><blockquote><p>只会输出一个文件</p></blockquote></li><li><p>多入口 Array / Object</p><blockquote><p>Array 只会输出一个文件</p></blockquote><blockquote><p>Object 会输出多个文件 ==&gt; 多页应用(MPA)</p></blockquote></li></ul></li></ul></li><li>output 输出 <ul><li>打包后资源输出到哪里去</li><li>输出的文件名叫什么</li></ul></li><li>loader 加载器 <ul><li>webpack 本身只能识别 json、js 模块，其他模块一旦加载就会报错.需要借助 loader 帮助 webpack 识别其它识别不了的模块</li></ul></li><li>plugins 插件 <ul><li>loader 功能有限，要想做功能更加强大的工作交给插件。比如在页面中自动引入打包生成的 js/css, 压缩 css, 拷贝文件等</li></ul></li><li>mode <ul><li>模式：开发环境（development）和生产环境（production）提供一系列默认配置, 用于简化配置</li></ul></li></ol><h2 id="webpack-基本配置" tabindex="-1">webpack 基本配置 <a class="header-anchor" href="#webpack-基本配置" aria-label="Permalink to &quot;webpack 基本配置&quot;">​</a></h2><ol><li>处理 JS 文件 <ul><li>eslint-loader</li></ul><blockquote><p>在 package.json 中配置 eslintConfig 来指示 eslint-loader 到底要干什么事enfore: &#39;pre&#39; 优先执行</p></blockquote><ul><li>babel-loader</li></ul><blockquote><p>在 webpack 配置中配置 babel 来指示 babel-loader 到底要干什么事 babel.config.js: 配置 webpack 的 preset 与 plugin</p></blockquote></li><li>处理 Vue 文件 <ul><li>vue-loader</li></ul></li><li>处理 JSX 文件 <ul><li>babel-loader</li></ul></li><li>处理 CSS 文件 <ul><li>开发环境：创建 style 标签插入样式 <ul><li>style-loader</li><li>css-loader</li><li>postcss-loader</li><li>less-loader / sass-loader / stylus-loader</li></ul></li><li>生产环境：提取单独 css 文件，将来通过 link 引入 <ul><li>MiniCssExtractPlugin.loader（还需要配置插件 new MiniCssExtractPlugin）</li><li>css-loader</li><li>postcss-loader</li><li>less-loader / sass-loader / stylus-loader</li></ul></li></ul></li><li>处理 HTML 文件 <ul><li>目标: 自动引入打包生成的 js/css html-webpack-plugin</li></ul></li><li>处理图片/字体/音视频文件 <ul><li>url-loader / file-loader limit: 10000 小于 10kb 一下的图片会被 base64 处理</li></ul></li></ol><h2 id="webpack配置层面优化" tabindex="-1">webpack配置层面优化 <a class="header-anchor" href="#webpack配置层面优化" aria-label="Permalink to &quot;webpack配置层面优化&quot;">​</a></h2>',7),p=l("ol",null,[l("li",null,[i("优化打包构建速度 "),l("ul",null,[l("li",null,[i("HMR 热模块替换 "),l("ul",null,[l("li",null,[i("为什么要用？ "),l("ul",null,[l("li",null,"默认情况下，一旦修改了代码，全部代码重新编译刷新，速度慢（全体刷新）")])]),l("li",null,[i("有什么作用？ "),l("ul",null,[l("li",null,"只更新修改的模块，其他模块不变（局部更新）")])]),l("li",null,[i("怎么使用？ "),l("ul",null,[l("li",{"hot:":"",true:""},"devServer:"),l("li",null,"new webpack.HotModuleReplacementPlugin()")])]),l("li",null,[i("注意： "),l("ul",null,[l("li",null,"默认情况下只有样式文件有 HMR 功能（style-loader），JS 是没有的开启 JS 的 HMR 功能："),l("li",null,"手写 JS 代码 --> module.hot.accpet('模块路径', () => {})"),l("li",null,"在 Vue 使用 --> vue-loader"),l("li",null,"在 React 使用 --> react-hot-loader")])])])]),l("li",null,[i("缓存 "),l("ul",null,[l("li",null,"eslint 和 babel 两个任务处理 JS 文件，时间一般会比较长，为了让其重新构建速度更快, 可以使用缓存。"),l("li",null,"eslint --> cache: true"),l("li",null,"babel --> cacheDirectory: true"),l("li",null,"cache-loader 放置在要缓存 loader 的前面"),l("li",null,"注意：一般只针对耗时长的任务：eslint-loader/babel-loader/vue-loader")])]),l("li",null,[i("oneOf "),l("ul",null,[l("li",null,[i("作用： "),l("ul",null,[l("li",null,"让模块只被一个 loader 处理，其他的就不看了(原本所有都会判断一下)"),l("li",null,"能够提升打包速度")])]),l("li",null,[i("注意： "),l("ul",null,[l("li",null,"eslint-loader: 处理 js, 需要先执行, 将其定义在 oneOf 的外面"),l("li",null,"babel-loader: 处理 js, 后执行, 将其定义在 oneOf 的内部")])])])]),l("li",null,[i("多进程打包 "),l("ul",null,[l("li",null,"过去: happyPack 现在: thread-loader"),l("li",null,"用法和 cache-loader 差不多，放在要使用 loader 前面"),l("li",null,"作用：开启多进程处理前面的任务，提升打包速度"),l("li",null,"注意：每个进程开启和通信都有开销，一般只针对耗时长的任务：babel-loader")])])])]),l("li",null,[i("兼容性处 "),l("ul",null,[l("li",null,[i("js "),l("ul",null,[l("li",null,"babel-loader: presets: ['@babel/preset-env'] 问题就是只能编译/转换简单语法"),l("li",null,"@babel/polyfill: 做复杂语法(新的 APi)兼容，问题是体积太大了"),l("li",null,"core-js: 在@babel/preset-env 基础上，增加了 useBuiltIns: 'usage'来实现按需打包"),l("li",null,"eslint-loader package.json 中配置 eslintConfig 来指示 eslint-loader 到底要干什么事enfore: 'pre' 优先执行")])]),l("li",null,[i("css "),l("ul",null,[l("li",null,"postcss-loader"),l("li",null,"内部使用 autoprefixer 插件, 给 w3c 样式自动添加厂商前缀"),l("li",null,"package.json 中指定 browserslist 来指示 postcss-loader 兼容性做到什么程度"),l("li",null,[i("开发环境 "),l("ul",null,[l("li",null,"style-loader"),l("li",null,"css-loader"),l("li",null,"postcss-loader"),l("li",null,"less-loader / sass-loader / stylus-loader")])]),l("li",null,[i("生产环境 "),l("ul",null,[l("li",null,"MiniCssExtractPlugin.loader（还需要配置插件 new MiniCssExtractPlugin）"),l("li",null,"css-loader"),l("li",null,"postcss-loader"),l("li",null,"less-loader / sass-loader / stylus-loader")])])])]),l("li",null,"vue vue-loader"),l("li",null,"html html-webpack-plugin 自动引入打包生成的 js/css"),l("li",null,"图片/字体/音视频文件 url-loader / file-loader limit: 10000 小于 10kb 一下的图片会被 base64 处理")])]),l("li",null,[i("拆分打包与压缩 "),l("ul",null,[l("li",null,[i("作用： "),l("ul",null,[l("li",null,"抽取公共代码"),l("li",null,"拆分多个文件，减少单个文件体积（避免单次请求时间过长）")])]),l("li",null,[i("配置： "),l("ul",null,[l("li",null,[i("多入口+ optimization "),l("ul",null,[l("li",null,"将node_modules抽取成单独模块"),l("li",null,"将多入口的公共模块也抽取成单独模块")])]),l("li",null,[i("单入口+optimization+import "),l("ul",null,[l("li",null,"将node_modules抽取成单独模块"),l("li",null,"动态导入语法import就能将某些文件抽取成单独模块")])]),l("li",null,"import（）动态引入模块"),l("li",null,[i("原生Js：在需要的回调函数中动态加载模块，"),l("code",null,"import（模块）.then()")]),l("li",null,[i("Vue："),l("code",null,"（）=>import（'./Foo.vue'）"),i("，实现路由组件懒加载")])])])])]),l("li",null,[i("资源预加载(prefetch) "),l("ul",null,[l("li",null,[i("作用 "),l("ul",null,[l("li",null,"让资源提前加载")])]),l("li",null,[i("区别： "),l("ul",null,[l("li",null,"preload 让当前页面的要使用资源加载（延后加载）"),l("li",null,"prefetch 让后面要使用资源提前加载（当前不需要使用）")])]),l("li",null,[i("使用： "),l("ul",null,[l("li",null,"import(/* webpackPrefetch: true */'./xxx')"),l("li",null,"import(/* webpackPreload: true */'./xxx') // 没有效果"),l("li",null,"问题：兼容性较差")])]),l("li",null,[i("使用chrome团队提供的一个工具包：preload-webpack-plugin "),l("ul",null,[l("li",null,"npm i-D preload-webpack-plugin@next //必须是最新的下一个版本")]),l("ul",null,[l("li",null,"对异步模块包使用：prefetch"),l("li",null,"对同步模块包使用：preload")])])])]),l("li",null,[i("生产环境时不生成 SourceMap "),l("ul",null,[l("li",null,"productionSourceMap: false 减少打包文件")])]),l("li",null,[i("文件名 hash 化=>利用浏览器缓存 "),l("ul",null,[l("li",null,"对打包文件名用上 contenthash ==> 某个 bundle 对应的模块文件内容发生改变文件名才会变化 ===> 利用浏览器缓存"),l("li",null,"hash、chunkhash、contenthash，首先生成效率越来越低，成本越来越高，影响范围越来越小，精度越来越细。"),l("li",null,"hash是一整个项目，一次打包，只有一个hash值，是项目级的"),l("li",null,"chunhash是从入口entry出发，到它的依赖，以及依赖的依赖，依赖的依赖的依赖，等等，一直下去，所打包构成的代码块(模块的集合)叫做一个chunk，也就是说，入口文件和它的依赖的模块构成的一个代码块，被称为一个chunk。"),l("li",null,"contenthash是哈希只跟内容有关系，内容不变，哈希值不变。与chunkhash的区别可以举上面contenthash的例子，同时可以说明contenthash跟内容有关，但是chunkhash会考虑很多因素，比如模块路径、模块名称、模块大小、模块id等等。")])]),l("li",null,[i("代码 Tree Shaking "),l("ul",null,[l("li",null,"效果: 打包时'摇掉'模块中没有被使用的代码 条件: 必须是 ES6 模块化导出且进行代码压缩时"),l("li",null,"必须使用 ES6 模块化（需要禁止@babel/preset-env 转换 ES6 模块化语法 modules: false）"),l("li",null,"开启 webpack 的生产模式（内部启用 TerserPlugin，用来压缩 JS 代码的插件，tree shaking 功能就是这个插件完成的）"),l("li",null,"在 package.json 配置 sideEffects 来指定哪些文件需要进行 tree shaking")])])],-1),k=s(`<h1 id="nginx" tabindex="-1">nginx <a class="header-anchor" href="#nginx" aria-label="Permalink to &quot;nginx&quot;">​</a></h1><h2 id="nginx基本功能" tabindex="-1">nginx基本功能 <a class="header-anchor" href="#nginx基本功能" aria-label="Permalink to &quot;nginx基本功能&quot;">​</a></h2><pre><code>* 作为服务器运行前端项目(gshop-client / gshop-admin)
* 作为代理服务器, 转发前端项目的请求到后台接口
* 配置api代理
</code></pre><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    server</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        listen</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 8081</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        server_name</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> localhost</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        # 处理所有与后面不匹配的请求</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        location</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            root</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> D:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\w</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">ork</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\o</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">nline</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\g</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">shop-client</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 项目资源的根目录</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            index</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> index.html</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> index.htm</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 首页页面</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            # try_files $uri $uri/ /index.html; # 所有 404 的请求返回 index 页面</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        # 处理所有/api 开头的请求</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        # 转发到后台接口地址</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        # 转发时不要去掉/api </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        location</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /api</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            proxy_pass</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> http://39.98.123.211</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    server</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        listen</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 8082</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        server_name</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> localhost</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        location</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            root</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> D:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\w</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">ork</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\o</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">nline</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\g</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">shop-admin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            index</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> index.html</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> index.htm</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        # 所有/api 开头的请求都转发到后台接口地址</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        # 转发时去掉/prod-api</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        location</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /prod-api/</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            proxy_pass</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> http://39.98.123.211/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span></code></pre></div><h2 id="nginx解决404" tabindex="-1">nginx解决404 <a class="header-anchor" href="#nginx解决404" aria-label="Permalink to &quot;nginx解决404&quot;">​</a></h2><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    location</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # 解决 history 模式, 浏览器刷新 404 问题</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    try_files</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $uri $uri</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /index.html</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 所有 404 的请求返回 index 页面</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span></code></pre></div><h2 id="vue和react对比" tabindex="-1">vue和react对比 <a class="header-anchor" href="#vue和react对比" aria-label="Permalink to &quot;vue和react对比&quot;">​</a></h2><ul><li>相同点 <ul><li>都有组件化思想</li><li>都支持服务器端渲染</li><li>都有Virtual DOM（虚拟dom）</li><li>数据驱动视图</li><li>都有支持native的方案：Vue的weex、React的React native</li><li>都有自己的构建工具：Vue的vue-cli、React的Create React App</li></ul></li><li>不同点 <ul><li>数据流向的不同。react从诞生开始就推崇单向数据流，而Vue是双向数据流</li><li>数据变化的实现原理不同。react使用的是不可变数据，而Vue使用的是可变的数据</li><li>组件化通信的不同。react中我们通过使用回调函数来进行通信的，而Vue中子组件向父组件传递消息有两种方式：事件和回调函数</li><li>diff算法不同。react主要使用diff队列保存需要更新哪些DOM，得到patch树，再统一操作批量更新DOM。Vue 使用双向指针，边对比，边更新DOM</li></ul></li></ul>`,8),r=[h,p,k];function u(o,d,c,F,g,E){return e(),n("div",null,r)}const C=a(t,[["render",u]]);export{b as __pageData,C as default};
