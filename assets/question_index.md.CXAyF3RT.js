import{av as a,p as n,m as e,aR as s,q as l,S as i}from"./chunks/framework.CtlH_-Gv.js";const y=JSON.parse('{"title":"webpack","description":"","frontmatter":{},"headers":[],"relativePath":"question/index.md","filePath":"question/index.md","lastUpdated":null}'),t={name:"question/index.md"},h=s('<h1 id="webpack" tabindex="-1">webpack <a class="header-anchor" href="#webpack" aria-label="Permalink to &quot;webpack&quot;">​</a></h1><h2 id="webpack-基本概念" tabindex="-1">webpack 基本概念 <a class="header-anchor" href="#webpack-基本概念" aria-label="Permalink to &quot;webpack 基本概念&quot;">​</a></h2><ol><li>entry 入口 <ul><li>以某个文件为入口开始打包</li><li>分类 <ul><li><p>单入口 String</p><blockquote><p>只会输出一个文件</p></blockquote></li><li><p>多入口 Array / Object</p><blockquote><p>Array 只会输出一个文件</p></blockquote><blockquote><p>Object 会输出多个文件 ==&gt; 多页应用(MPA)</p></blockquote></li></ul></li></ul></li><li>output 输出 <ul><li>打包后资源输出到哪里去</li><li>输出的文件名叫什么</li></ul></li><li>loader 加载器 <ul><li>webpack 本身只能识别 json、js 模块，其他模块一旦加载就会报错.需要借助 loader 帮助 webpack 识别其它识别不了的模块</li></ul></li><li>plugins 插件 <ul><li>loader 功能有限，要想做功能更加强大的工作交给插件。比如在页面中自动引入打包生成的 js/css, 压缩 css, 拷贝文件等</li></ul></li><li>mode <ul><li>模式：开发环境（development）和生产环境（production）提供一系列默认配置, 用于简化配置</li></ul></li></ol><h2 id="webpack-基本配置" tabindex="-1">webpack 基本配置 <a class="header-anchor" href="#webpack-基本配置" aria-label="Permalink to &quot;webpack 基本配置&quot;">​</a></h2><ol><li>处理 JS 文件 <ul><li>eslint-loader</li></ul><blockquote><p>在 package.json 中配置 eslintConfig 来指示 eslint-loader 到底要干什么事enfore: &#39;pre&#39; 优先执行</p></blockquote><ul><li>babel-loader</li></ul><blockquote><p>在 webpack 配置中配置 babel 来指示 babel-loader 到底要干什么事 babel.config.js: 配置 webpack 的 preset 与 plugin</p></blockquote></li><li>处理 Vue 文件 <ul><li>vue-loader</li></ul></li><li>处理 JSX 文件 <ul><li>babel-loader</li></ul></li><li>处理 CSS 文件 <ul><li>开发环境：创建 style 标签插入样式 <ul><li>style-loader</li><li>css-loader</li><li>postcss-loader</li><li>less-loader / sass-loader / stylus-loader</li></ul></li><li>生产环境：提取单独 css 文件，将来通过 link 引入 <ul><li>MiniCssExtractPlugin.loader（还需要配置插件 new MiniCssExtractPlugin）</li><li>css-loader</li><li>postcss-loader</li><li>less-loader / sass-loader / stylus-loader</li></ul></li></ul></li><li>处理 HTML 文件 <ul><li>目标: 自动引入打包生成的 js/css html-webpack-plugin</li></ul></li><li>处理图片/字体/音视频文件 <ul><li>url-loader / file-loader limit: 10000 小于 10kb 一下的图片会被 base64 处理</li></ul></li></ol><h2 id="webpack配置层面优化" tabindex="-1">webpack配置层面优化 <a class="header-anchor" href="#webpack配置层面优化" aria-label="Permalink to &quot;webpack配置层面优化&quot;">​</a></h2>',6),p=l("ol",null,[l("li",null,[i("优化打包构建速度 "),l("ul",null,[l("li",null,[i("HMR 热模块替换 "),l("ul",null,[l("li",null,[i("为什么要用？ "),l("ul",null,[l("li",null,"默认情况下，一旦修改了代码，全部代码重新编译刷新，速度慢（全体刷新）")])]),l("li",null,[i("有什么作用？ "),l("ul",null,[l("li",null,"只更新修改的模块，其他模块不变（局部更新）")])]),l("li",null,[i("怎么使用？ "),l("ul",null,[l("li",{"hot:":"",true:""},"devServer:"),l("li",null,"new webpack.HotModuleReplacementPlugin()")])]),l("li",null,[i("注意： "),l("ul",null,[l("li",null,"默认情况下只有样式文件有 HMR 功能（style-loader），JS 是没有的开启 JS 的 HMR 功能："),l("li",null,"手写 JS 代码 --> module.hot.accpet('模块路径', () => {})"),l("li",null,"在 Vue 使用 --> vue-loader"),l("li",null,"在 React 使用 --> react-hot-loader")])])])]),l("li",null,[i("缓存 "),l("ul",null,[l("li",null,"eslint 和 babel 两个任务处理 JS 文件，时间一般会比较长，为了让其重新构建速度更快, 可以使用缓存。"),l("li",null,"eslint --> cache: true"),l("li",null,"babel --> cacheDirectory: true"),l("li",null,"cache-loader 放置在要缓存 loader 的前面"),l("li",null,"注意：一般只针对耗时长的任务：eslint-loader/babel-loader/vue-loader")])]),l("li",null,[i("oneOf "),l("ul",null,[l("li",null,[i("作用： "),l("ul",null,[l("li",null,"让模块只被一个 loader 处理，其他的就不看了(原本所有都会判断一下)"),l("li",null,"能够提升打包速度")])]),l("li",null,[i("注意： "),l("ul",null,[l("li",null,"eslint-loader: 处理 js, 需要先执行, 将其定义在 oneOf 的外面"),l("li",null,"babel-loader: 处理 js, 后执行, 将其定义在 oneOf 的内部")])])])]),l("li",null,[i("多进程打包 "),l("ul",null,[l("li",null,"过去: happyPack 现在: thread-loader"),l("li",null,"用法和 cache-loader 差不多，放在要使用 loader 前面"),l("li",null,"作用：开启多进程处理前面的任务，提升打包速度"),l("li",null,"注意：每个进程开启和通信都有开销，一般只针对耗时长的任务：babel-loader")])])])]),l("li",null,[i("兼容性处 "),l("ul",null,[l("li",null,[i("js "),l("ul",null,[l("li",null,"babel-loader: presets: ['@babel/preset-env'] 问题就是只能编译/转换简单语法"),l("li",null,"@babel/polyfill: 做复杂语法(新的 APi)兼容，问题是体积太大了"),l("li",null,"core-js: 在@babel/preset-env 基础上，增加了 useBuiltIns: 'usage'来实现按需打包"),l("li",null,"eslint-loader package.json 中配置 eslintConfig 来指示 eslint-loader 到底要干什么事enfore: 'pre' 优先执行")])]),l("li",null,[i("css "),l("ul",null,[l("li",null,"postcss-loader"),l("li",null,"内部使用 autoprefixer 插件, 给 w3c 样式自动添加厂商前缀"),l("li",null,"package.json 中指定 browserslist 来指示 postcss-loader 兼容性做到什么程度"),l("li",null,[i("开发环境 "),l("ul",null,[l("li",null,"style-loader"),l("li",null,"css-loader"),l("li",null,"postcss-loader"),l("li",null,"less-loader / sass-loader / stylus-loader")])]),l("li",null,[i("生产环境 "),l("ul",null,[l("li",null,"MiniCssExtractPlugin.loader（还需要配置插件 new MiniCssExtractPlugin）"),l("li",null,"css-loader"),l("li",null,"postcss-loader"),l("li",null,"less-loader / sass-loader / stylus-loader")])])])]),l("li",null,"vue vue-loader"),l("li",null,"html html-webpack-plugin 自动引入打包生成的 js/css"),l("li",null,"图片/字体/音视频文件 url-loader / file-loader limit: 10000 小于 10kb 一下的图片会被 base64 处理")])]),l("li",null,[i("拆分打包与压缩 "),l("ul",null,[l("li",null,[i("作用： "),l("ul",null,[l("li",null,"抽取公共代码"),l("li",null,"拆分多个文件，减少单个文件体积（避免单次请求时间过长）")])]),l("li",null,[i("配置： "),l("ul",null,[l("li",null,[i("多入口+ optimization "),l("ul",null,[l("li",null,"将node_modules抽取成单独模块"),l("li",null,"将多入口的公共模块也抽取成单独模块")])]),l("li",null,[i("单入口+optimization+import "),l("ul",null,[l("li",null,"将node_modules抽取成单独模块"),l("li",null,"动态导入语法import就能将某些文件抽取成单独模块")])]),l("li",null,"import（）动态引入模块"),l("li",null,[i("原生Js：在需要的回调函数中动态加载模块，"),l("code",null,"import（模块）.then()")]),l("li",null,[i("Vue："),l("code",null,"（）=>import（'./Foo.vue'）"),i("，实现路由组件懒加载")])])])])]),l("li",null,[i("资源预加载(prefetch) "),l("ul",null,[l("li",null,[i("作用 "),l("ul",null,[l("li",null,"让资源提前加载")])]),l("li",null,[i("区别： "),l("ul",null,[l("li",null,"preload 让当前页面的要使用资源加载（延后加载）"),l("li",null,"prefetch 让后面要使用资源提前加载（当前不需要使用）")])]),l("li",null,[i("使用： "),l("ul",null,[l("li",null,"import(/* webpackPrefetch: true */'./xxx')"),l("li",null,"import(/* webpackPreload: true */'./xxx') // 没有效果"),l("li",null,"问题：兼容性较差")])]),l("li",null,[i("使用chrome团队提供的一个工具包：preload-webpack-plugin "),l("ul",null,[l("li",null,"npm i-D preload-webpack-plugin@next //必须是最新的下一个版本")]),l("ul",null,[l("li",null,"对异步模块包使用：prefetch"),l("li",null,"对同步模块包使用：preload")])])])]),l("li",null,[i("生产环境时不生成 SourceMap "),l("ul",null,[l("li",null,"productionSourceMap: false 减少打包文件")])]),l("li",null,[i("文件名 hash 化=>利用浏览器缓存 "),l("ul",null,[l("li",null,"对打包文件名用上 contenthash ==> 某个 bundle 对应的模块文件内容发生改变文件名才会变化 ===> 利用浏览器缓存"),l("li",null,"hash、chunkhash、contenthash，首先生成效率越来越低，成本越来越高，影响范围越来越小，精度越来越细。"),l("li",null,"hash是一整个项目，一次打包，只有一个hash值，是项目级的"),l("li",null,"chunhash是从入口entry出发，到它的依赖，以及依赖的依赖，依赖的依赖的依赖，等等，一直下去，所打包构成的代码块(模块的集合)叫做一个chunk，也就是说，入口文件和它的依赖的模块构成的一个代码块，被称为一个chunk。"),l("li",null,"contenthash是哈希只跟内容有关系，内容不变，哈希值不变。与chunkhash的区别可以举上面contenthash的例子，同时可以说明contenthash跟内容有关，但是chunkhash会考虑很多因素，比如模块路径、模块名称、模块大小、模块id等等。")])]),l("li",null,[i("代码 Tree Shaking "),l("ul",null,[l("li",null,"效果: 打包时'摇掉'模块中没有被使用的代码 条件: 必须是 ES6 模块化导出且进行代码压缩时"),l("li",null,"必须使用 ES6 模块化（需要禁止@babel/preset-env 转换 ES6 模块化语法 modules: false）"),l("li",null,"开启 webpack 的生产模式（内部启用 TerserPlugin，用来压缩 JS 代码的插件，tree shaking 功能就是这个插件完成的）"),l("li",null,"在 package.json 配置 sideEffects 来指定哪些文件需要进行 tree shaking")])])],-1),k=s(`<h2 id="说说如何借助webpack来优化前端性能" tabindex="-1">说说如何借助webpack来优化前端性能？ <a class="header-anchor" href="#说说如何借助webpack来优化前端性能" aria-label="Permalink to &quot;说说如何借助webpack来优化前端性能？&quot;">​</a></h2><pre><code>&gt; webpack是一个模块打包工具，可以使用webpack管理模块，并分析模块间的依赖关系最终编译输出模块为html、JavaScript和css以及各种静态文件，让开发更加高效
</code></pre><h2 id="通过webpack优化前端的手段有" tabindex="-1">通过webpack优化前端的手段有： <a class="header-anchor" href="#通过webpack优化前端的手段有" aria-label="Permalink to &quot;通过webpack优化前端的手段有：&quot;">​</a></h2><pre><code>&gt; JS代码压缩、CSS代码压缩、Html文件代码压缩、文件大小压缩、图片压缩、Tree Shaking、代码分离、内联 chunk
</code></pre><h1 id="nginx" tabindex="-1">nginx <a class="header-anchor" href="#nginx" aria-label="Permalink to &quot;nginx&quot;">​</a></h1><h2 id="nginx基本功能" tabindex="-1">nginx基本功能 <a class="header-anchor" href="#nginx基本功能" aria-label="Permalink to &quot;nginx基本功能&quot;">​</a></h2><pre><code>* 作为服务器运行前端项目(gshop-client / gshop-admin)
* 作为代理服务器, 转发前端项目的请求到后台接口
* 配置api代理
</code></pre><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    server</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        listen</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 8081</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        server_name</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> localhost</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        # 处理所有与后面不匹配的请求</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        location</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            root</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> D:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\w</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">ork</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\o</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">nline</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\g</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">shop-client</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 项目资源的根目录</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            index</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> index.html</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> index.htm</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 首页页面</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            # try_files $uri $uri/ /index.html; # 所有 404 的请求返回 index 页面</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        # 处理所有/api 开头的请求</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        # 转发到后台接口地址</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        # 转发时不要去掉/api </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        location</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /api</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            proxy_pass</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> http://39.98.123.211</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    server</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        listen</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 8082</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        server_name</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> localhost</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        location</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            root</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> D:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\w</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">ork</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\o</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">nline</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\g</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">shop-admin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            index</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> index.html</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> index.htm</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        # 所有/api 开头的请求都转发到后台接口地址</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        # 转发时去掉/prod-api</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        location</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /prod-api/</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            proxy_pass</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> http://39.98.123.211/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span></code></pre></div><h2 id="nginx解决404" tabindex="-1">nginx解决404 <a class="header-anchor" href="#nginx解决404" aria-label="Permalink to &quot;nginx解决404&quot;">​</a></h2><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    location</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # 解决 history 模式, 浏览器刷新 404 问题</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    try_files</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $uri $uri</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /index.html</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 所有 404 的请求返回 index 页面</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span></code></pre></div><h2 id="token存在sessionstorage还是loaclstorage" tabindex="-1">token存在sessionstorage还是loaclstorage <a class="header-anchor" href="#token存在sessionstorage还是loaclstorage" aria-label="Permalink to &quot;token存在sessionstorage还是loaclstorage&quot;">​</a></h2><p>token：验证身份的令牌，一般就是用户通过账号密码登录后，服务端把这些凭证通过加君</p><ul><li>存loaclstorage里，后期每次请求接口都需要把它当作一个字段传给后台</li><li>存cookie中，会白动发送，缺点就是不能跨域</li></ul><blockquote><p>如果存在localstorage中，容易被xss攻击，但是如果做好了对应的措施，那么是利大于 如果存在cookie中会有CSRF攻击</p></blockquote><h2 id="token的登录流程" tabindex="-1">token的登录流程 <a class="header-anchor" href="#token的登录流程" aria-label="Permalink to &quot;token的登录流程&quot;">​</a></h2><ol><li>客户端用账号密码请求登录</li><li>服务端收到请求后，需要去验证账号密码</li><li>验证成功之后，服务端会签发一个token，把这 个token发送给客户端</li><li>容户端收到token后保存起来，可以放在cookie也可以是localstorage</li><li>客户端每次向服务端发送请求资源的时候，都需要携带这 个token</li><li>服务端收到请求，接着去验证客户端里的token，验证成功才会返回客户端请求的数据</li></ol><h2 id="了解过jwt吗" tabindex="-1">了解过JWT吗 <a class="header-anchor" href="#了解过jwt吗" aria-label="Permalink to &quot;了解过JWT吗&quot;">​</a></h2><blockquote><p>JSONWebToken 通过了JSON形式作为在web应用中的令牌，可以在各方之间安全的把信息作为JSON对象传输(信息传输、授杈)</p></blockquote><p>JWT的认证流程</p><ol><li>前端把账号密码发送给后端的接口</li><li>后端核对账号密码成功后，把用户id等其他信息作为JWT负载，把它和头部分别进base64编码拼接后签名，形成一个JWT (token) .</li><li>前端每次请求时都会把JWT放在HTTP请求头的Authorization字段内</li><li>后端检查是否存在，如果存在就验证JVT的有效性（签名是否正确，token是否过期）</li><li>验证通过后后端使用JWT中包含的用户信总进行其他的操作，井返回对应结果</li></ol><h2 id="处理无感登陆" tabindex="-1">处理无感登陆 <a class="header-anchor" href="#处理无感登陆" aria-label="Permalink to &quot;处理无感登陆&quot;">​</a></h2><ol><li>在相应其中拦截，判街token返回过期后，调用刷新token的接口</li><li>后端返回过期时间，前端判断token的过期时间，去调用刷新token的按口</li><li>写定时器，定时刷新token接口</li></ol><blockquote><p>流程：</p></blockquote><ol><li>登录成功后保存token 和 refresh_token</li><li>在响应拦截器中对401状态码引入刷新token的api方法调用</li><li>替换保存本地新的token</li><li>把错误对象里的token替换</li><li>再次发送未完成的请求</li><li>如果refresh_token期了，判新是否过期，过期了就清楚所有token重新登录</li></ol><h2 id="vue和react对比" tabindex="-1">vue和react对比 <a class="header-anchor" href="#vue和react对比" aria-label="Permalink to &quot;vue和react对比&quot;">​</a></h2><ul><li>相同点 <ul><li>都有组件化思想</li><li>都支持服务器端渲染</li><li>都有Virtual DOM（虚拟dom）</li><li>数据驱动视图</li><li>都有支持native的方案：Vue的weex、React的React native</li><li>都有自己的构建工具：Vue的vue-cli、React的Create React App</li></ul></li><li>不同点 <ul><li>数据流向的不同。react从诞生开始就推崇单向数据流，而Vue是双向数据流</li><li>数据变化的实现原理不同。react使用的是不可变数据，而Vue使用的是可变的数据</li><li>组件化通信的不同。react中我们通过使用回调函数来进行通信的，而Vue中子组件向父组件传递消息有两种方式：事件和回调函数</li><li>diff算法不同。react主要使用diff队列保存需要更新哪些DOM，得到patch树，再统一操作批量更新DOM。Vue 使用双向指针，边对比，边更新DOM</li></ul></li></ul>`,26),o=[h,p,k];function r(u,d,c,g,F,b){return e(),n("div",null,o)}const C=a(t,[["render",r]]);export{y as __pageData,C as default};
